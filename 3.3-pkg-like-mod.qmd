# 3.3 Package-like Modules

The previous part teaches you on how to import / export data from module, and in this part, you'll learn on how to create a module that mimics the package system in R and package system in other languages such as Python. One of the strengths of **{box}** is that you don't need to create an R package just to store the R codes and make it accessible to other end-users. Because of this package, you can mimic the way on how Python packages are created. It's modular, maintainable, and accessible.

---

## 3.3.1 Create modules from the root folder 

Recall the `not_func.r` script. Keep it and this time, create another scripts named `convert.r` and `hello_world.r`. 

::: {.callout-tip title="Did you know? "}

*Recall that `#' @export` is only necessary when you are exporting specific part of the assigned R code into the namespace.*
When `#' @export` is placed, it triggers the Roxygen2 functionality, where it keeps the public namespace into the private namespace. 

:::

::: panel-tabset

###  Converting temperatures

Copy this code:

```r
celsius_to_fahrenheit = function (celsius) {
    fahrenheit = (celsius * 9/5) + 32
    fahrenheit
}

fahrenheit_to_celsius = function (fahrenheit) {
    celsius = (fahrenheit - 32) * 5/9
    celsius
}
```

### Simple greetings

This example is an example code from the official documentation of **{box}** package. 

``` r
#' @export
hello = function (name) {
    message('Hello, ', name, '!')
}

#' @export
bye = function (name) {
    message('Goodbye ', name, '!')
}
```

:::

And access them like:

```{r}
box::use(
    ./module/convert, 
    greet = ./module/hello_world
)

temperature = 212

glue::glue(
    "{temperature} degrees Fahrenheit is equivalent to {convert$fahrenheit_to_celsius(temperature)} degrees Celsius"
)

greet$hello("Amy")
```

If you have `__init__.r` initialization file already, you can do the following:

```{r}
box::use(
    md = ./module
)

temperature = 212

glue::glue(
    "{temperature} degrees Fahrenheit is equivalent to {md$convert$fahrenheit_to_celsius(temperature)} degrees Celsius"
)

md$hello_world$hello("Amy")
```

And by the way, you can apply aliases for the script accessed as a module, not limited to functions and any objects:

``` r
box::use(
    ./module[hw = hello_world],
    ./module[cv = convert], 
    ./module[nf = not_func]
)
```

## 3.3.2 Create a module from subfolders

Under the **{module}**, let's create a subfolder named `statistics`, where the small set of statistical functions are contained in separate scripts. Don't forget the `__init__.r` initialization file. 

Here is the structure:

```bash
statistics/
├── __init__.r
├── cor.r
├── corrr.r
└── time_series.r
```

### i. `cor.r`:

```{r}
#| code-fold: true
#| eval: false
#' Simple implementation of Pearson's Product-Moment Correlation
#' 
#' @param x A numeric vector that stands for "independent" variable
#' @param y A numeric vector that stands for "dependent" variable
#' 
#' @export
custom_cor = function (x, y) {
    if (length(x) != length(y)) {
        stop("x and y must have the same length.")
    }
    
    x_centered = x - mean(x)
    y_centered = y - mean(y)
    
    dot_product = sum(x_centered * y_centered)
    
    norm_x = sqrt(sum(x_centered ^ 2))
    norm_y = sqrt(sum(y_centered ^ 2))
    
    r = dot_product / (norm_x * norm_y)
    r
}
```

### ii. `corrr.r`:

```{r}
#| code-fold: true
#| eval: false
box::use(
    rlang[enquos, eval_tidy, abort, is_null], 
    glue[glue], 
    dplyr[select], 
    stats[cor],
    purrr[map, every]
)

#' Correlation matrix from the entire data frame
#' @keywords internal
corr_matrix = function (data, method, use) {
    out = cor(as.matrix(data), method = method, use = use)
    out
}

#' Scalar correlation coefficient from raw numeric vectors
#' @keywords internal
corr_vectors = function (values, method, use) {
    if (!every(values, is.numeric)) {
        abort("All arguments must be numeric.")
    }
    
    if (length(values) == 2) {
        out = cor(values[[1]], values[[2]], method = method, use = use)
    } else {
        out = cor(do.call(cbind, values), method = method, use = use)
    }
    
    out
}

#' Data masking functionality
#' @keywords internal
corr_tidy = function (dots, data, method, use) {
    if (length(dots) == 2) {
        x = eval_tidy(dots[[1]], data = data)
        y = eval_tidy(dots[[2]], data = data)
        out = cor(x, y, method = method, use = use)
    } else {
        dat = select(data, !!!dots)
        out = cor(as.matrix(dat), method = method, use = use)
    }
  
    out
}

#' Calculating correlation with 3 cases
#' 
#' This function provides three ways to calculate correlations:
#' 
#' **Case 1: Full correlation matrix**
#' - When `...` is empty and `data` is provided
#' - Returns correlation matrix for all columns in the dataset
#' - Example: `corr(data = mtcars)`
#' 
#' **Case 2: Raw numeric vectors**
#' - When `...` contains vectors but `data` is NULL
#' - Evaluates arguments as standalone numeric vectors
#' - Example: `corr(c(1, 2, 3), c(4, 5, 6))`
#' 
#' **Case 3: Tidy evaluation with data**
#' - When both `...` and `data` are provided
#' - Uses data masking to select columns from the dataset
#' - Example: `corr(speed, dist, data = cars)`
#' 
#' @param ... Column names (with data masking), raw numeric vectors, or empty for full matrix.
#'   Can specify no columns (Case 1), raw vectors (Case 2), or column names (Case 3).
#' @param data A data frame. If provided, data masking is applied to `...`.
#'   Required for Case 1 and Case 3.
#' @param method Correlation method: "pearson" (default), "kendall", or "spearman".
#'   Passed to \code{stats::cor()}.
#' @param use Method for handling missing values. Passed to \code{stats::cor()}.
#'   Default is "everything".
#' 
#' @return A correlation coefficient (scalar) when two variables are specified,
#'   or a correlation matrix when multiple variables or full dataset is used.
#'   It throws an error when both `data` and `...` are not provided. 
#' 
#' @examples
#' box::use(
#'     corr = ./module/statistics/corrr
#' )
#' 
#' corr$corr(speed, dist, data = cars) 
#' corr$corr(data = mtcars)
#' 
#' @export
corr = function(..., data = NULL, method = c("pearson", "kendall", "spearman"), use = "everything") {
    dots = enquos(...) 
    method = match.arg(method)
    
    # Case 1: No arguments - return full correlation matrix
    if (length(dots) == 0) {
        if (is_null(data)) {
            abort("`.data` must be provided when both `x` and `y` are missing.")
        }
        return(corr_matrix(data, method, use))
    }
    
    # Case 2: Arguments without data - evaluate as raw vectors
    if (is_null(data)) {
        values = map(dots, eval_tidy)
        return(corr_vectors(values, method, use))
    }
    
    # Case 3: Data masking
    out = corr_tidy(dots, data, method, use)
    out
}

#' Pipe-friendly correlation calculation
#' 
#' A pipe-optimized wrapper around \code{corr()} that always requires a dataset
#' as the first argument, making it suitable for use in piped workflows with
#' \code{|>} or \code{\%>\%}.
#' 
#' **Behavior:**
#' -  When `...` is empty: Returns correlation matrix for all columns in `.data`
#' -  When `...` specifies columns: Returns correlation matrix for selected columns only
#' 
#' @param .data A data frame (required). Cannot be NULL.
#' @param ... Column names to select from `.data`. If empty, uses all columns.
#'    Supports tidy selection.
#' @param alternative Direction of alternative hypothesis: "two.sided" (default),
#'    "less", or "greater". Currently not implemented.
#' @param method Correlation method: "pearson" (default), "kendall", or "spearman".
#'    Passed to \code{corr()}.
#' @param use Method for handling missing values. Passed to \code{stats::cor()}.
#'    Default is "everything".
#' 
#' @return A correlation matrix for the specified or all columns in `.data`.
#' 
#' @examples
#' box::use(
#'     corr = ./module/statistics/corrr
#' )
#' 
#' mtcars |> 
#'     corr$cor_pipe()
#' 
#' mtcars |> 
#'     corr$cor_pipe(mpg, hp, wt)
#' 
#' iris |> 
#'     corr$cor_pipe(Sepal.Length, Sepal.Width, method = "spearman")
#' 
#' @export
cor_pipe = function(.data, ..., alternative = "two.sided", method = c("pearson", "kendall", "spearman"), use = "everything") {
    method = match.arg(method)
    
    if (is_null(.data)) {
        abort("`.data` must be provided, it cannot be NULL in this function.")
    }
    
    dots = enquos(...)
    
    if (length(dots) == 0) {
        return(corr(data = .data, method = method))
    }
    
    out = corr(!!!dots, data = .data, method = method)
    out
}
```

### iii. `time_series.r`

```{r}
#| code-fold: true
#| eval: false
#' Simple Moving Average
#' 
#' Calculates a simple moving average (also known as rolling mean) for a time 
#' series using a specified window size. Each value in the output is the mean 
#' of a window of consecutive observations from the input series.
#' 
#' @param x A numeric vector representing the time series data
#' @param win An integer specifying the window size (number of observations to 
#'   average). Default is 3
#' 
#' @return A numeric vector of length n - win + 1, where n is the length of x.
#'   Each element represents the mean of a window of size win from the original 
#'   series
#' 
#' @details The function computes moving averages by sliding a window of fixed 
#'   size across the time series. The output length is reduced because only 
#'   complete windows are used.
#' 
#' @examples
#' box::use(
#'     md_ts = ./module/time_series
#' )
#' 
#' time(AirPassengers)
#' md_ts$moving_average(AirPassengers)
#' 
#' @export
moving_average = function (x, win = 3) {
    nn = length(x)
    ll = nn - win + 1
    res = numeric(ll)
    
    for (i in 1 : ll) {
        res[i] = mean(x[i : (i + win - 1)])
    }
    res
}

#' Simple Exponential Smoothing
#' 
#' Performs simple exponential smoothing on a time series using a specified
#' smoothing parameter alpha. The smoothed values are computed recursively,
#' with each smoothed value being a weighted average of the current observation
#' and the previous smoothed value.
#' 
#' @param x A numeric vector representing the time series data
#' @param alpha A numeric value between 0 and 1 representing the smoothing 
#'   parameter. Higher values give more weight to recent observations. 
#'   Default is 0.3
#' @param init Initial value for smoothing. If NULL (default), uses the first
#'   observation as the initial value
#' 
#' @return A numeric vector of the same length as x containing the smoothed values
#' 
#' @details The simple exponential smoothing formula is:
#'   S[t] = alpha * x[t] + (1 - alpha) * S[t-1]
#'   where S[1] is initialized to x[1] or a specified initial value.
#'   
#'   Alpha controls the rate of decay for past observations. Values closer to 1
#'   give more weight to recent observations, while values closer to 0 give more
#'   weight to historical data.
#' 
#' @examples
#' box::use(
#'     md_ts = ./module/time_series
#' )
#' 
#' md_ts$SES(AirPassengers)
#' 
#' @export
SES = function (x, alpha = 0.3, init = NULL) {
    n = length(x)
    res = numeric(n)
    
    if (is.null(init)) {
        res[1] = x[1]
    } else {
        res[1] = init
    }
    
    for (i in 2 : n) {
        res[i] = alpha * x[i] + (1 - alpha) * res[i - 1]
    }
    
    res
}

#' Inefficient ACF Calculation
#' 
#' Computes the autocorrelation function (ACF) for a time series using an 
#' inefficient but explicit implementation. The ACF measures the correlation 
#' between observations at different time lags.
#' 
#' @param x A numeric vector representing the time series data
#' @param lag_max An integer specifying the maximum lag at which to calculate 
#'   the ACF. Default is 10
#' 
#' @return A numeric vector of length lag_max + 1 containing the autocorrelation
#'   values at lags 0 through lag_max. The first element (lag 0) is always 1.
#' 
#' @details This function computes the sample autocorrelation coefficient at 
#'   each lag using the formula:
#'   rho[t] = sum((x[k] - mean(x)) * (x[k-t] - mean(x))) / sum((x[i] - mean(x))^2)
#'   
#'   Note: This is an intentionally inefficient implementation for educational 
#'   purposes. For production use, consider using stats::acf() instead.
#' 
#' @examples
#' box::use(
#'     md_ts = ./module/time_series
#' )
#' 
#' md_ts$ACF(AirPassengers)
#' 
#' @export
ACF = function (x, lag_max = 10) {
    out = numeric(lag_max + 1)
    mu_x = mean(x, na.rm = TRUE)
    n = length(x)
    denom = 0
    
    for (i in 1 : n) {
        denom = denom + (x[i] - mu_x)^2
    }
    
    for (t in 0 : lag_max) {
        num = 0
        
        for (k in (t + 1) : n) {
            num = num + (x[k] - mu_x) * (x[k - t] - mu_x)
        }
        
        out[t + 1] = num / denom
    }
    
    out
}

#' Inefficient PACF Calculation
#' 
#' Computes the partial autocorrelation function (PACF) for a time series using 
#' an inefficient but explicit implementation via the Durbin-Levinson recursion. 
#' The PACF measures the correlation between observations at different lags after 
#' removing the effects of intermediate lags.
#' 
#' @param x A numeric vector representing the time series data
#' @param lag_max An integer specifying the maximum lag at which to calculate 
#'   the PACF. Default is 10
#' 
#' @return A numeric vector of length lag_max containing the partial 
#'   autocorrelation values at lags 1 through lag_max
#' 
#' @details This function uses the Durbin-Levinson algorithm to compute partial 
#'   autocorrelations from the autocorrelation function. The PACF at lag k 
#'   represents the correlation between x[t] and x[t-k] after controlling for 
#'   the linear effects of x[t-1], x[t-2], ..., x[t-k+1].
#'   
#'   The function first computes the ACF, then applies the recursive formula:
#'   phi[n,n] = (rho[n] - sum(phi[n-1,k] * rho[n-k])) / (1 - sum(phi[n-1,i] * rho[i]))
#'   
#'   Note: This is an intentionally inefficient implementation for educational 
#'   purposes. For production use, consider using stats::pacf() instead.
#' 
#' @examples
#' box::use(
#'     md_ts = ./module/time_series
#' )
#' 
#' md_ts$PACF(AirPassengers)
#' 
#' @seealso \code{\link{ACF}} for the autocorrelation function
#' 
#' @export
PACF = function (x, lag_max = 10) {
    rho = ACF(x, lag_max = lag_max)[-1]
    
    phi = matrix(nrow = lag_max, ncol = lag_max)
    res = numeric(lag_max)
    
    phi[1, 1] = rho[1]
    res[1] = phi[1, 1]
    
    for (n in 2 : lag_max) {
        num = rho[n]
        
        for (k in 1 : (n - 1)) {
            num = num - phi[n - 1, k] * rho[n - k]
        }
        
        denom = 1
        
        for (i in 1 : (n - 1)) { 
            denom = denom - phi[n - 1, i] * rho[i] 
        }
        
        phi[n, n] = num / denom
        
        for (k in 1 : (n - 1)) {
            phi[n, k] = phi[n - 1, k] - phi[n, n] * phi[n - 1, n - k]
        }
        
        res[n] = phi[n, n]
    }
    
    res
}
```

Access all of the modules within `statistics` by:

```{r}
box::use(
    md_sts = ./module/statistics
)
```

Example:

```{r}
with(cars, md_sts$cor$custom_cor(speed, dist))

cor_pipe = md_sts$corrr$cor_pipe

mtcars |> 
    cor_pipe(mpg, hp, disp, qsec)

mas = md_sts$time_series$moving_average(AirPassengers, win = 3)

plot(
    seq_along(AirPassengers),
    AirPassengers, 
    type = "l",
    col = "blue", 
    lwd = 2, 
    xlab = "Time Index", 
    ylab = "Passengers", 
    main = "AirPassengers with Moving Averages"
)

lines(mas, col = "red")
```


The **{statistics}** *submodule* is accessible: 

```r
box::use(
    ./module/statistics
)
```

If `__init__.r` file under **{statistics}** subfolder is initialized through:

```r
#' @export
box::use(
    ./cor_nse,
    ./cor,
    ./moving_average
)
```

*I'll explain about nested modules in the Chapter 3.4.*

::: {.callout-tip title="Recall Chapter 3.1.2"}

If you access **{statistics}** subfolder as a module, under **{module}** folder like this:

```{r}
box::use(
    ./module[st = statistics]
)
```

The **{st}** module will not be loaded into the current (root) environment, but loaded under **{module}** environment

![](Images/img-c3.3.2.jpg)

:::
