# Getting Started

Before we dive deeper, install `box` from CRAN first:

``` r
install.packages("box")
```

or you can install the development version from R-universe:

``` r
install.packages('box', repos = 'https://klmr.r-universe.dev')
```

## Why Box

I recommend the `box` package because it brings and simplifies modular programming in R. As described in its official documentation, it provides two key benefits:

1.  It facilitates modular code writing by treating files and folders as independent, nestable modules, so you don’t need to wrap reusable code into packages.

2.  It introduces a more powerful, less error-prone syntax for importing code from packages or modules, enabling explicit control over what names to import and restricting their scope.

With `box`, R users (or useRs) can take advantage of a modular approach within R.

## Understanding Module Paths and Root Directory

Before I proceed, one crucial aspect of using box is understanding how it locates and imports modules. The package uses a root directory concept to resolve module paths:

1.  Root Directory: By default, box searches for modules starting from your project's root directory.

2.  Module Path Resolution:

    -   Paths starting with ./ are relative to the current file

    -   Paths without leading dots are relative to the root directory

    -   Forward slashes (/) are used, even on Windows

Knowing this helps streamline module management with `box`.

## Basic Usage Example

When we say module, it refers to a script file or a folder loaded using `box::use`.

To get started, create a script name `mod.r/mod.R` in the directory from the assumed directory structure:

``` bash
# my_project/
# ├── mod.r
```

In `mod.r/mod.R`, copy this code:

``` r
box::use(
  stats[lm]
)

fit_and_predict = function (formula, data, ...) {
    lm(formula, data, ...)
}
```

and then save the script. After you save the script, you can now import `mod` as a module:

``` r
box::use(
  ./mod
)
```

No need to quote the argument since the `box` package uses one of the core features in R: Non-standard evaluation or NSE. No, I don't recommend quoting the arguments. On the other hand, if the script you saved is under the folder of the root directory, so assume that this is the directory structure:

``` bash
# my_project/
# ├── folder1/
# │   ├──mod.r
```

To call the module from the script, you can do this following:

```r
box::use(
  ./folder1/mod
)
```

and the `mod` script can be called as a module.

## Common Import Patterns

Here are some typical module import scenarios:

1.  Import entire script/folder as a module:

``` r
box::use(
  ./mod
)
```

::: {.callout-note collapse="true"}
If it is a script, you can directly call the object inside `mod`, i.e. `mod$fobj`. While `mod` is a folder, you can't call it unless you have initialization file, typically saved into `__init__.r` file, so you might have to call the script inside the folder, i.e. `./mod/.../...[...]` to use it like this: `mod$mod1$obj`. For further details, I'll explain this in Chapter 3.
:::

2.  Import specific script in a folder as a module:

``` r
box::use(
  ./mod/mod1
)
```

3.  Import specific objects inside a script being explicitly called as a module:

``` r
box::use(
  ./mod[obj1, obj2, ...]
)
```

if `mod` is a script. If it is a folder, the imported objects will be a module, not an R objects like functions.

This is the same as indexing a vector in R.

4.  Import and name a module:

``` r
box::use(
  md = ./mod
)
```

::: {.callout-tip}
Remember, this will work if `mod` is a script, not a folder.
:::

5.  Rename an object inside the module

``` r
box::use(
  ./mod[ob1 = obj1, ob2 = obj2, ...]
)
```

::: {.callout-tip}
Note: You can also do this instead:

``` r
box::use(
  ./mod[ob1 = obj1, obj2, ...]
)
```

only if you load the specific object and rename some of them.
:::

6.  Import from subdirectories

``` r
box::use(
  ./mod/mod1,                      # From subdir/module.R
  ./folder/mod/mod1                # From deep/nested/module.R
)
```

In my opinion, this is the most optimized solution but requires verbose syntax to perform.

## Troubleshooting Module Imports

Common issues and solutions:

1.  Module Not Found:

    -   Verify path is relative to root directory

    -   Ensure file exists with `.R/.r` extension

2.  Path Resolution:

    ``` r
    # ❌ Wrong:
    box::use(modules)                  # Missing ./
    box::use(\modules\my_module)       # Wrong slashes

    # ✅ Correct:
    box::use(./modules/my_module)      # Relative to current file
    box::use(modules/my_module)        # Relative to root (if set)
    ```

    It is important to know that you can do `box::use(modules)` only if `modules` is a package (this will be explain in Chapter 2).

3.  Best Practices:

    -   Use relative paths with `./` for clarity

    -   Keep module files in a dedicated directory

    -   Use consistent naming conventions


