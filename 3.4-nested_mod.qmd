# 3.4 Accessing modules in any depths

One of the good parts about **{box}** package is it allows to access deep nested scripts folders in any depth as modules. Nested modules allow you to organize your code into hierarchical structures, similar to how packages in Python can contain *submodules*. In **{box}**, this is achieved using scripts and folders with `__init__.r` files in any depth.

---

## Understanding initialization

The `__init__.r` file serves several important purposes:

1.  It marks a directory as a module
2.  It controls which objects are exported from the module
3.  It can contain module-level code and documentation
4.  It can aggregate functionality from *submodules*

---

### Basic `__init__.r` Example

Let's take back what we've started. I already created `__init__.r` files under **{modules}** and **{statistics}** subfolder, so let's look at a basic `__init__.r` file for **{modules}** directory:

```r
#' @export
box::use(
    ./convert,
    ./hello_world,
    ./not_func,
    ./statistics
)
```

While for `statistics`:

```r
#' @export
box::use(
    ./cor_nse,
    ./cor,
    ./moving_average,
    ./cor_npar
)
```

As you can see, we've gathered the files we've been created from the previous parts. The `__init__.r` file under **{modules}** contains:

-  The entire namespaces from `hello_world.r`, `convert.r`, and `not_func.r`
-  Imports the entire `statistics` submodule
-  Creates and exports a new function greet that combines functionality


If you're Python user, then this will be too familiar to you.

To import the whole `Modules` module:

```{r}
box::use(
    ./Modules
)
```

But don't do this:

```r
box::use(
    Modules
)
```

Because without `./` that signifies the root path directory implies the package you wanted to import, not a folder/script.

## Example Usage

```{r}
temp = Modules$convert$fahrenheit_to_celsius(212)
glue::glue(
    "{212} degrees Fahrenheit is equivalent to {temp} degrees Celsius"
)

```

### From `statistics` module

```{r}
corr = Modules$statistics$cor$custom_cor

r_coef = with(cars, corr(speed, dist))

glue::glue(
    "Correlation between speed and distance in `cars` dataset: {r_coef}"
)

```

You can also rename the module you wanted to import:

```r
box::use(
    md = ./Modules
)
```

## Explicit namespace exportation

By default, `box` encapsulates namespaces, ensuring that each moduleâ€™s functions and objects remain distinct. However, if you prefer not to encapsulate namespaces, you can use the `[...]` syntax to export all functions from a script.

For example, to export all functions from scripts in `Modules`, modify its `__init__.r`:

```r
#' @export
box::use(
    ./convert[...],
    ./hello_world[...],
    ./not_func[...],
    ./statistics
)
```

### Avoid Namespace Pollution

::: {.callout-warning}
Why there's no `[...]` in `./statistics`? After all, `statistics` is a subfolder as a submodule, not a script, so be cautious when dealing with submodules. That's why, if you include `[...]` for `statistics` in `Modules/__init__.r`, it will export everything from `statistics`, potentially polluting **{modules}** namespace. 
:::

Instead, apply `[...]` within `statistics/__init__.r` itself:

```r
#' @export
box::use(
    ./cor_nse[...],
    ./cor[...],
    ./moving_average[...],
    ./cor_npar[...]
)
```

This approach keeps the namespaces clean and manageable.

## Remember

Don't forget the following:

i.  initialization - Apply `__init__.r` into the namespace of your module.
ii. Apply `./` in `box::use` - This is just a module, not an external package.





