# 3.1 Creating a Module

I'll start on how to construct a module preliminarily. To demonstrate how to construct modules, let’s work with an example folder named **{module}**. Each script or subfolder within this directory will serve as a separate module or submodule. The files are expected to be *empty*, since I'll be addressing some of them, or you can visit [**{module}**](https://github.com/kisha126/modules-in-r/module) to view the pre-written code.

---

## 3.1.1 The structure

Here's the structure of the **{module}** folder I initialize:

``` bash
module/
├── __init__.r
├── convert.r
├── data
│   └── flights.rds
├── hello_world.r
├── not_func.r
├── statistics
│   ├── __init__.r
│   ├── cor.r
│   ├── cor_nse.r
│   └── time_series.r
```

*Expect to have additional contents here soon. Otherwise, check out the original source code. *

### 3.1.1.1 Initialization

The `__init__.r` file is a special file, acts as the initialization file which marks **{module}** folder as a *package*, in which will be executed once you import **{module}** as a *module*. 

-   Really beneficial because you don't need to explicitly load the script as modules, repetitively. 
-   It can be used to load or expose specific functions or objects from the submodules within this folder.
-   You'll be always using this special file to treat folders as modules, equivalent to what made Python modules. 

### 3.1.1.2 Scripts from root folder

Here are the scripts under the root folder that you can directly import:

-   `hello_world.r`: A simple script is using the examples from **{box}** official documentation. 

    -   This is for demonstration purposes only.

-   `convert.r`: This script contains functions to convert temperatures from Celsius to Fahrenheit and vice versa.
-   Assorted scripts: Not functions belongs to the objects within the module that can be also exported explicitly. 
    
    -   `not_func.r`: This script is where the data structures, such as an atomic vector, a list, a matrix, a data frame, or an n-dimensional array, are contained. 

### 3.1.1.3 Subfolders

-   `statistics/`: A *subfolder*, dedicated for (a small set of) statistical functions. Subfolders can be referred to *submodules*, just like scripts under the folder as a module, and can be used to categorically group related functionalities within a larger module. Once loaded, it is imported as **{statistics}** module. 

    -   **`__init__.r`**: This is still required. You'll always be using this special file to mark folders as a module, even within subfolders. For this one, it marks the `statistics/` subfolder as a submodule. This exposes specific functions under the scripts, or entire scripts as a module, under **{statistics}** module.
    -   **`cor.r`**: A script containing a simple function for calculating correlation coefficients.
    -   **`corrr.r`**: A script, which I extends the `cor.r`, dependent to `stats::cor()` and **{tidyverse}** APIs, for calculating the correlations, including the nonparametric ones. 
    -   **`time_series.r`**: A script that contains functions under "Time Series Analysis" umbrella. 

-   `data/`: Another assorted folder that contains the binaries of the data. Typically saved as `*.rds` or `*.parquet`. 

---

## 3.1.2 Importing **{module}**

Now that you’ve seen the structure of the **{module}** folder, you can reuse my codes, by forking [**{module}**](https://github.com/kisha126/modules-in-r/module), found at the source code of this book, into any specified directory. Let's recall a bit about what is on about in [Chapter 2: Importing packages](2.1-loading-pkg.qmd). This time, we import scripts / folders as a module instead. 

### 3.1.2.1 Valid imports

Here are the valid imports: 

1.  With alias

    ``` r
    box::use(
        md = ./module
    )
    ```
    
    It's up to you if you want another name, besides `md`. 
    
2.  Without alias

    ``` r
    box::use(
        ./module
    )
    ```

3.  Load specific subfolder as a module

    ``` r
    box::use(
        md_stats = ./module[statistics]
    )
    ```
    
    This is equivalent to: 

    ``` r
    box::use(
        md_stats = ./module/statistics
    )
    ```
    
    as long as **{module}** has an initialization file. 

4.  Load specific script as a module

    ``` r
    box::use(
        md_dt = ./module[not_func]
    )
    ```
    
    Note: This is not entirely equivalent to: 

    ``` r
    box::use(
        md_dt = ./module/not_func
    )
    ```
    
    because it will append another environment in the current environment, specifically under **{module}** environment. Additionally, it will create `md_dt` module, which loads the entire **{module}**, only if you did the former.  
    
    ![](Images/img-c3.1.2.jpg)

::: callout-note
Do not forget to put `./` prefix to load specific modules in your project workspace. The lack of `./` prefix is only valid for R packages. For the deep nested modules, this will be deeply tackled in [Chapter 3.4: Accessing modules in any depths](3.4-nested_mod.qmd). 
:::

## 3.1.3 Reloading modules

During development, most particularly when you import a particular module, you’ll sometimes modify its source code — for example, tweaking functions or adding new ones. However, **{box}** modules are cached after their first import. This means that changes you make to your module’s code won’t automatically take effect until you explicitly reload it.

### 3.1.3.1 Basic Reloading

To reload a module, **{box}** provides the function `box::reload()`. This clears the cached version and re-imports the module, ensuring that the latest code changes are applied.

If you’ve imported the module, such as:

```
box::use(
    md = ./module
)
```

and you made some changes within its source code, you can reload it simply by:

``` r
box::reload(md)
```

And note: This is not allowed to reload *submodules* under `md` module:

``` r
box::reload(md$statistics)
```

### 3.1.3.2 Reload benefits

Reloading is particularly useful when:

-   You’re iteratively developing and testing module code
-   You’ve edited scripts that are already imported
-   You want to ensure that any updates to exported objects are reflected in your current R session

My advise for production code, however, you generally don’t need to use `box::reload()` — modules should be stable and imported once.
