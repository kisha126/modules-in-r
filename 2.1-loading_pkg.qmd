# 2.1 Array of Import Monikers

## 2.1.1 Base R vs **{box}** Approach

Let's first compare the traditional R approach with **{box}**:

| Aspect            | Base R                         | **{box}** Approach                 |
|-------------------|--------------------------------|------------------------------------|
| Loading Method    | `library(dplyr)`               | `box::use(dplyr)`                  |
| Namespace Impact  | Attaches to global namespace   | Module-scoped imports              |
| Conflict Handling | May cause naming conflicts     | Explicit imports prevent conflicts |
| Code Clarity      | Dependencies implicit          | Dependencies explicitly declared   |
| Performance       | Loads entire package namespace | More controlled                    |

Oh, and there's also `require()` function, an evil-ler twin of `library()` function, where it won't just attach the *entire* namespace to the search path, it returns `TRUE` (if the package exists; `FALSE` if it doesn't) when executed, and it is TOO inconsistent by as it fails silently — “fails silently” means that a function fails without stopping the program or showing a clear error message. 

## 2.1.2 Importing External Packages

The table not enough for you? This book will further explain. The **{box}** package provides a flexible and explicit way to import external packages and their functions. Let's explore the different importing methods:

### 2.1.2.1 Basic Imports

This book already shows you the basic importation using `box::use()`. But, the `box::use()` function uses `...`, also called "ellipsis", and it acts as a "placeholder" that allows multiple arguments, similar to Python's `*args` and `**kwargs`, thus allows multiple package imports. Since this allows you to import multiple packages and their functions in a single call, you don't have to bother yourself calling multiple calls, like:

``` r
box::use(dplyr[filter, select, mutate])
box::use(ggplot2[ggplot, geom_point])
box::use(stats[lm])

# Usage
data |> filter(col > 0)     # Use filter directly
data |> select(col1, col2)  # Use select directly
```

Instead, do the following:

::: {.callout-note icon=false title="Import specific functions" appearance="minimal"}

``` r
box::use(
    dplyr[filter, select, mutate],
    ggplot2[ggplot, geom_point],
    stats[lm]
)

# Usage
data |> filter(col > 0)     
data |> select(col1, col2)  
mtcars |> lm(formula = mpg ~ wt)
```
:::

In this case, the nuance being: Hard coding multiple calls is avoided

::: {.callout-tip}

#### Additional information

-   Still allows specified functions to be imported
-   Functions are available directly by their names
-   Functions are scoped to your current module
-   Other functions from these packages remain unavailable

:::

### 2.1.2.2 Importing the entire package

Do not confuse this with `library()`, where it attaches the *entire* namespace to the search path. The **{box}** fortunately resolves this: Instead of loading the package onto the global environment, the namespace that includes the functions and other objects, such as data frame, will be encapsulated as an *environment* (a data structure) with its name. 

``` r
box::use(
    dplyr
)  

# Usage:
dplyr$filter(data, col > 0)    
dplyr$select(data, col1, col2)
```

How beautiful this may be? I have several verdicts: 

-   The entire package namespace becomes available as an *environment*
-   All functions are (and must) be accessed using the package name as a prefix and `$` operator
-   This prevents namespace pollution while maintaining access to all functions
-   Useful when you need many functions from a package

The use of aliases also allowed:

``` r
box::use(
    dpr = dplyr, 
    tdr = tidyr
)  

# Usage:
dpr$filter(data, col1 > 0) |> 
    tdr$pivot_longer(cols = col2)
```

### 2.1.2.3 Granular Imports with Aliases

The **{box}** package absolves namespace clashes, which commonly occur when different packages have functions with the same name.

When you import the namespace, you are allowed to spice up things a little bit by renaming the imports. This is particularly useful when you have 2 packages to be used and you want to use them both at once. For instance, the **{dplyr}**'s `filter` function, and as you attach the **{dplyr}** namespace, it will mask the existing functions from the global namespace, namely the **{stats}**' `filter` function. This induces namespace clash, and trust me, you may not want this happening. 

My solution: You can load the `filter()` function from the **{dplyr}** namespace through the following: 

``` r
box::use(
    dplyr[filter_rows = filter],  # dplyr's filter becomes filter_rows
    stats[filter_ts = filter]     # stats' filter becomes filter_ts
)

# Usage:
data |> filter_rows(col > 0)      
AirPassengers |> filter_ts()      
```

::: {.callout-note}

Granular imports in R's `library()` is also allowed using `include.only` parameter. 

For example: 

``` r
library(dplyr, include.only = c("select", "filter"))
```

But still no *alias* gimmicks and doesn't even leverage non-standard evaluation, where it treats `include.only` arguments as an object, called as a name, unlike `box::use()`. 

R version 4.4 and above has a shorthand of `library(pkg, include.only = c('fn1', 'fn2'))`: Introducing the `base::use()`. 

Example usage: 

``` r
use(dplyr, c("select", "filter"))
```

Also inconsistent as it silently fails, and I won't highly recommend this. 

::: 

### 2.1.2.4 Import special characters

The functions like `%>%` from **{magrittr}** is one of the function with special characters. 

### 2.1.2.5 Wildcard import

The true equivalent of `library(pkg)` is something like `box::use[...]`. Yet again, we use `...`, also called "ellipsis". The use of `...` sets as a "wildcard", and this, while being *granular*, imports all the namespace withing the package (or modules). The Python's equivalent would be `from pkg import *`.  

For example:

``` r
box::use(
    dplyr[...]
)
```

## 2.1.3 Best Practices for Package Imports

But, of course, R packages have strengths, but don't forget their flaws. I will enumerate the *do's* in **{box}** package:

### 2.1.3.1 Be Specific with Imports

#### a. Avoid importing everything

The use of *wildcards*, i.e. `...` within the granular imports through `[...]` is a shortcut to import the namespace, but you are importing everything here. 

``` r
box::use(
    dplyr[...]
)
```

Don't do this in actual practice, or it will create a mess in the global namespace, just like `library()`. As the *Zen of Python* said: "Explicit is better than implicit." 

#### b. Import only what you need

Of course, in several times, you only import specific parts of the package only. For instance, when you are aggregating data frame with **{dplyr}**, you often only needs `filter()`, `select()`, `mutate()`, `group_by()`, and `summarise()`. Mind you that there are a total of 293 exported namespace (will be less than that if you don't count the *pseudo-functions*, such as `across()` and `where()`), and you only need 5 out of the total exports. 

This approach is better because it is explicit and you can rename those imports: 

``` r
box::use(
    dplyr[select, filter, mutate]
)
```

### 2.1.3.2 Group Related Imports

For better clarity, comments `#` are allowed, and so, you can group the imports by functionality. 

``` r
box::use(
    # Data manipulation
    dplyr[select, filter, mutate],
    tidyr[pivot_longer, pivot_wider],
    
    # Statistical functions
    stats[lm, t.test],
    
    # Visualization
    ggplot2[ggplot, geom_point, theme_minimal]
)
```

### 2.1.3.3 Handle Naming Conflicts

As I discussed in Chapter 2.1.2.3, you are allowed to place an alias within the imports, so that the namespace clash will be resolved. 

The most prominent example is `dplyr::filter()` and `stats::filter()`. 

``` r
box::use(
    dplyr[dplyr_filter = filter],
    stats[stats_filter = filter]
)
```

*Rename them whatever you want to employ clarity. *

### Otherwise

::: {.callout-warning title="Otherwise"}

Trust me, I've been this a long time ago: not following any of those practices. So, if you don't do the following practices, you'll create inconsistent and unpredictable flaws. Keep up the good work and do the best practices.

:::

## 2.1.4 Troubleshooting Package Imports

I will show you solutions if you have similar errors like the following.

Common issues and solutions:

1.  **Package Not Found**

    ``` r
    # ❌ Error: package not installed
    box::use(missingpkg[func, ...])

    # ✅ First install the package
    install.packages("missingpkg")
    ```

2.  **Function Not Found**

    ``` r
    # ❌ Error: object not exported from package namespace
    box::use(dplyr[nonexistent_function])

    # ✅ Check package documentation for correct function name
    box::use(dplyr[select, filter])
    ```

## Summary

So, you see, using **{box}** for dealing with external packages and package management in R offers you these several advantages:

-   Explicit dependency declaration
-   Better namespace control
-   Reduced conflicts
-   More efficient loading

In the next chapter, we'll explore how to create and reuse your own modules effectively.
